# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/actionpack/all/actionpack.rbi
#
# actionpack-5.2.3
module ActionPack
  def self.gem_version; end
  def self.version; end
end
module ActionPack::VERSION
end
module Rack
end
module ActionDispatch
  def self.test_app; end
  def self.test_app=(obj); end
  def test_app; end
  def test_app=(obj); end
  extend ActiveSupport::Autoload
end
class ActionDispatch::IllegalStateError < StandardError
end
module ActionDispatch::Http
  extend ActiveSupport::Autoload
end
module ActionDispatch::Session
end
class ActionDispatch::Railtie < Rails::Railtie
end
module Mime
  def self.[](type); end
  def self.fetch(type); end
end
class Mime::Mimes
  def <<(type); end
  def delete_if; end
  def each; end
  def initialize; end
  def symbols; end
  include Enumerable
end
class Mime::Type
  def ==(mime_type); end
  def ===(list); end
  def =~(mime_type); end
  def all?; end
  def eql?(other); end
  def hash; end
  def html?; end
  def initialize(string, symbol = nil, synonyms = nil); end
  def method_missing(method, *args); end
  def ref; end
  def respond_to_missing?(method, include_private = nil); end
  def self.lookup(string); end
  def self.lookup_by_extension(extension); end
  def self.parse(accept_header); end
  def self.parse_data_with_trailing_star(type); end
  def self.parse_trailing_star(accept_header); end
  def self.register(string, symbol, mime_type_synonyms = nil, extension_synonyms = nil, skip_lookup = nil); end
  def self.register_alias(string, symbol, extension_synonyms = nil); end
  def self.register_callback(&block); end
  def self.unregister(symbol); end
  def string; end
  def symbol; end
  def synonyms; end
  def to_a; end
  def to_ary; end
  def to_s; end
  def to_str; end
  def to_sym; end
end
class Mime::Type::AcceptItem
  def <=>(item); end
  def index; end
  def index=(arg0); end
  def initialize(index, name, q = nil); end
  def name; end
  def name=(arg0); end
  def q; end
  def q=(arg0); end
  def to_s; end
end
class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end
  def self.sort!(list); end
end
class Mime::AllType < Mime::Type
  def all?; end
  def html?; end
  def initialize; end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Mime::NullType
  def method_missing(method, *args); end
  def nil?; end
  def ref; end
  def respond_to_missing?(method, _); end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module ActionDispatch::Routing
  extend ActiveSupport::Autoload
end
module ActionDispatch::Journey
end
class ActionDispatch::Journey::Router
  def ast; end
  def custom_routes; end
  def eager_load!; end
  def filter_routes(path); end
  def find_routes(req); end
  def initialize(routes); end
  def match_head_routes(routes, req); end
  def match_routes(routes, req); end
  def partitioned_routes; end
  def recognize(rails_req); end
  def routes; end
  def routes=(arg0); end
  def serve(req); end
  def simulator; end
  def visualizer; end
end
class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end
  def self.escape_path(path); end
  def self.escape_segment(segment); end
  def self.normalize_path(path); end
  def self.unescape_uri(uri); end
end
class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape(component, pattern); end
  def escape_fragment(fragment); end
  def escape_path(path); end
  def escape_segment(segment); end
  def percent_encode(unsafe); end
  def unescape_uri(uri); end
end
class ActionDispatch::Journey::Routes
  def add_route(name, mapping); end
  def anchored_routes; end
  def ast; end
  def clear; end
  def clear_cache!; end
  def custom_routes; end
  def each(&block); end
  def empty?; end
  def initialize; end
  def last; end
  def length; end
  def partition_route(route); end
  def routes; end
  def simulator; end
  def size; end
  include Enumerable
end
module ActionController
end
class ActionController::ActionControllerError < StandardError
end
class ActionController::BadRequest < ActionController::ActionControllerError
  def initialize(msg = nil); end
end
class ActionController::RenderError < ActionController::ActionControllerError
end
class ActionController::RoutingError < ActionController::ActionControllerError
  def failures; end
  def initialize(message, failures = nil); end
end
class ActionController::UrlGenerationError < ActionController::ActionControllerError
end
class ActionController::MethodNotAllowed < ActionController::ActionControllerError
  def initialize(*allowed_methods); end
end
class ActionController::NotImplemented < ActionController::MethodNotAllowed
end
class ActionController::MissingFile < ActionController::ActionControllerError
end
class ActionController::SessionOverflowError < ActionController::ActionControllerError
  def initialize(message = nil); end
end
class ActionController::UnknownHttpMethod < ActionController::ActionControllerError
end
class ActionController::UnknownFormat < ActionController::ActionControllerError
end
class ActionDispatch::Journey::Formatter
  def build_cache; end
  def cache; end
  def clear; end
  def extract_parameterized_parts(route, options, recall, parameterize = nil); end
  def generate(name, options, path_parameters, parameterize = nil); end
  def initialize(routes); end
  def match_route(name, options); end
  def missing_keys(route, parts); end
  def named_routes; end
  def non_recursive(cache, options); end
  def possibles(cache, options, depth = nil); end
  def routes; end
end
module ActionDispatch::Journey::Formatter::RegexCaseComparator
  def self.===(regex); end
end
class ActionDispatch::Journey::Scanner
  def eos?; end
  def initialize; end
  def next_token; end
  def pos; end
  def pre_match; end
  def scan; end
  def scan_setup(str); end
end
class ActionDispatch::Journey::Format
  def evaluate(hash); end
  def initialize(parts); end
  def self.required_path(symbol); end
  def self.required_segment(symbol); end
end
class ActionDispatch::Journey::Format::Parameter < Struct
  def escape(value); end
  def escaper; end
  def escaper=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module ActionDispatch::Journey::Visitors
end
class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def unary(node); end
  def visit(node); end
  def visit_CAT(n); end
  def visit_DOT(n); end
  def visit_GROUP(n); end
  def visit_LITERAL(n); end
  def visit_OR(n); end
  def visit_SLASH(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end
class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end
  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit(node, seed); end
  def visit_CAT(n, seed); end
  def visit_DOT(n, seed); end
  def visit_GROUP(n, seed); end
  def visit_LITERAL(n, seed); end
  def visit_OR(n, seed); end
  def visit_SLASH(n, seed); end
  def visit_STAR(n, seed); end
  def visit_SYMBOL(n, seed); end
end
class ActionDispatch::Journey::Visitors::FormatBuilder < ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def binary(node); end
  def terminal(node); end
  def visit_GROUP(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end
class ActionDispatch::Journey::Visitors::Each < ActionDispatch::Journey::Visitors::FunctionalVisitor
  def visit(node, block); end
end
class ActionDispatch::Journey::Visitors::String < ActionDispatch::Journey::Visitors::FunctionalVisitor
  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def visit_GROUP(node, seed); end
end
class ActionDispatch::Journey::Visitors::Dot < ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed = nil); end
  def binary(node, seed); end
  def initialize; end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit_CAT(node, seed); end
  def visit_GROUP(node, seed); end
  def visit_OR(node, seed); end
  def visit_STAR(node, seed); end
end
module ActionDispatch::Journey::Nodes
end
class ActionDispatch::Journey::Nodes::Node
  def cat?; end
  def each(&block); end
  def group?; end
  def initialize(left); end
  def left; end
  def left=(arg0); end
  def literal?; end
  def memo; end
  def memo=(arg0); end
  def name; end
  def star?; end
  def symbol?; end
  def terminal?; end
  def to_dot; end
  def to_s; end
  def to_sym; end
  def type; end
  include Enumerable
end
class ActionDispatch::Journey::Nodes::Terminal < ActionDispatch::Journey::Nodes::Node
  def symbol; end
  def terminal?; end
end
class ActionDispatch::Journey::Nodes::Literal < ActionDispatch::Journey::Nodes::Terminal
  def literal?; end
  def type; end
end
class ActionDispatch::Journey::Nodes::Dummy < ActionDispatch::Journey::Nodes::Literal
  def initialize(x = nil); end
  def literal?; end
end
class ActionDispatch::Journey::Nodes::Symbol < ActionDispatch::Journey::Nodes::Terminal
  def default_regexp?; end
  def initialize(left); end
  def name; end
  def regexp; end
  def regexp=(arg0); end
  def symbol; end
  def symbol?; end
  def type; end
end
class ActionDispatch::Journey::Nodes::Slash < ActionDispatch::Journey::Nodes::Terminal
  def type; end
end
class ActionDispatch::Journey::Nodes::Dot < ActionDispatch::Journey::Nodes::Terminal
  def type; end
end
class ActionDispatch::Journey::Nodes::Unary < ActionDispatch::Journey::Nodes::Node
  def children; end
end
class ActionDispatch::Journey::Nodes::Group < ActionDispatch::Journey::Nodes::Unary
  def group?; end
  def type; end
end
class ActionDispatch::Journey::Nodes::Star < ActionDispatch::Journey::Nodes::Unary
  def name; end
  def star?; end
  def type; end
end
class ActionDispatch::Journey::Nodes::Binary < ActionDispatch::Journey::Nodes::Node
  def children; end
  def initialize(left, right); end
  def right; end
  def right=(arg0); end
end
class ActionDispatch::Journey::Nodes::Cat < ActionDispatch::Journey::Nodes::Binary
  def cat?; end
  def type; end
end
class ActionDispatch::Journey::Nodes::Or < ActionDispatch::Journey::Nodes::Node
  def children; end
  def initialize(children); end
  def type; end
end
class ActionDispatch::Journey::Parser < Racc::Parser
  def _reduce_1(val, _values); end
  def _reduce_10(val, _values); end
  def _reduce_15(val, _values); end
  def _reduce_16(val, _values); end
  def _reduce_17(val, _values); end
  def _reduce_18(val, _values); end
  def _reduce_2(val, _values); end
  def _reduce_7(val, _values); end
  def _reduce_8(val, _values); end
  def _reduce_9(val, _values); end
  def _reduce_none(val, _values); end
  def initialize; end
  def next_token; end
  def parse(string); end
  def self.parse(string); end
  include ActionDispatch::Journey::Nodes
end
class ActionDispatch::Journey::Route
  def app; end
  def ast; end
  def conditions; end
  def constraints; end
  def defaults; end
  def dispatcher?; end
  def eager_load!; end
  def format(path_options); end
  def glob?; end
  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, internal = nil); end
  def internal; end
  def ip; end
  def match_verb(request); end
  def matches?(request); end
  def name; end
  def parts; end
  def path; end
  def precedence; end
  def required_default?(key); end
  def required_defaults; end
  def required_keys; end
  def required_parts; end
  def requirements; end
  def requires_matching_verb?; end
  def score(supplied_keys); end
  def segment_keys; end
  def segments; end
  def self.build(name, app, path, constraints, required_defaults, defaults); end
  def self.verb_matcher(verb); end
  def verb; end
  def verbs; end
end
module ActionDispatch::Journey::Route::VerbMatchers
end
class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end
  def self.verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end
  def initialize(verb); end
  def verb; end
end
class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end
  def self.verb; end
end
module ActionDispatch::Journey::Path
end
class ActionDispatch::Journey::Path::Pattern
  def =~(other); end
  def anchored; end
  def ast; end
  def build_formatter; end
  def eager_load!; end
  def initialize(ast, requirements, separators, anchored); end
  def match(other); end
  def names; end
  def offsets; end
  def optional_names; end
  def regexp_visitor; end
  def required_names; end
  def requirements; end
  def self.build(path, requirements, separators, anchored); end
  def self.from_string(string); end
  def source; end
  def spec; end
  def to_regexp; end
end
class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp < ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def initialize(separator, matchers); end
  def visit_CAT(node); end
  def visit_DOT(node); end
  def visit_GROUP(node); end
  def visit_LITERAL(node); end
  def visit_OR(node); end
  def visit_SLASH(node); end
  def visit_STAR(node); end
  def visit_SYMBOL(node); end
end
class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp < ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def accept(node); end
end
class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end
  def captures; end
  def initialize(names, offsets, match); end
  def length; end
  def names; end
  def post_match; end
  def to_s; end
end
class ActionDispatch::Journey::Router::RoutingError < StandardError
end
module ActionDispatch::Journey::NFA
end
module ActionDispatch::Journey::NFA::Dot
  def to_dot; end
end
module ActionDispatch::Journey::GTG
end
class ActionDispatch::Journey::GTG::TransitionTable
  def []=(from, to, sym); end
  def accepting?(state); end
  def accepting_states; end
  def add_accepting(state); end
  def add_memo(idx, memo); end
  def as_json(options = nil); end
  def eclosure(t); end
  def initialize; end
  def memo(idx); end
  def memos; end
  def move(t, a); end
  def states; end
  def states_hash_for(sym); end
  def to_svg; end
  def transitions; end
  def visualizer(paths, title = nil); end
  include ActionDispatch::Journey::NFA::Dot
end
class ActionDispatch::Journey::GTG::Builder
  def ast; end
  def build_followpos; end
  def endpoints; end
  def firstpos(node); end
  def followpos(node); end
  def followpos_table; end
  def initialize(root); end
  def lastpos(node); end
  def nullable?(node); end
  def root; end
  def symbol(edge); end
  def transition_table; end
end
class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end
  def memos; end
end
class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end
  def memos(string); end
  def tt; end
end
class ActionDispatch::Journey::NFA::TransitionTable
  def []=(i, f, s); end
  def accepting; end
  def accepting=(arg0); end
  def accepting?(state); end
  def accepting_states; end
  def add_memo(idx, memo); end
  def alphabet; end
  def eclosure(t); end
  def following_states(t, a); end
  def initialize; end
  def inverted; end
  def memo(idx); end
  def memos; end
  def merge(left, right); end
  def move(t, a); end
  def states; end
  def transitions; end
  include ActionDispatch::Journey::NFA::Dot
end
class ActionDispatch::Journey::NFA::Visitor < ActionDispatch::Journey::Visitors::Visitor
  def initialize(tt); end
  def terminal(node); end
  def visit_CAT(node); end
  def visit_GROUP(node); end
  def visit_OR(node); end
end
class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end
  def transition_table; end
end
class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end
  def memos; end
end
class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end
  def initialize(transition_table); end
  def match(string); end
  def simulate(string); end
  def tt; end
end
class ActionDispatch::Http::Headers
  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def each(&block); end
  def env; end
  def env_name(key); end
  def fetch(key, default = nil); end
  def include?(key); end
  def initialize(request); end
  def key?(key); end
  def merge!(headers_or_env); end
  def merge(headers_or_env); end
  def self.from_hash(hash); end
  include Enumerable
end
module ActionDispatch::Http::Cache
end
module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end
  def fresh?(response); end
  def if_modified_since; end
  def if_none_match; end
  def if_none_match_etags; end
  def not_modified?(modified_at); end
end
module ActionDispatch::Http::Cache::Response
  def cache_control; end
  def cache_control_headers; end
  def cache_control_segments; end
  def date; end
  def date=(utc_time); end
  def date?; end
  def etag=(weak_validators); end
  def etag?; end
  def generate_strong_etag(validators); end
  def generate_weak_etag(validators); end
  def handle_conditional_get!; end
  def last_modified; end
  def last_modified=(utc_time); end
  def last_modified?; end
  def merge_and_normalize_cache_control!(cache_control); end
  def prepare_cache_control!; end
  def strong_etag=(strong_validators); end
  def strong_etag?; end
  def weak_etag=(weak_validators); end
  def weak_etag?; end
end
module ActionDispatch::Http::MimeNegotiation
  def accepts; end
  def content_mime_type; end
  def content_type; end
  def format(view_path = nil); end
  def format=(extension); end
  def format_from_path_extension; end
  def formats; end
  def formats=(extensions); end
  def has_content_type?; end
  def negotiate_mime(order); end
  def use_accept_header; end
  def valid_accept_header; end
  def variant; end
  def variant=(variant); end
  extend ActiveSupport::Concern
end
module ActionDispatch::Http::Parameters
  def binary_params_for?(controller, action); end
  def parameters; end
  def params; end
  def params_parsers; end
  def parse_formatted_parameters(parsers); end
  def path_parameters; end
  def path_parameters=(parameters); end
  def set_binary_encoding(params, controller, action); end
  extend ActiveSupport::Concern
end
class ActionDispatch::Http::Parameters::ParseError < StandardError
  def initialize; end
end
module ActionDispatch::Http::Parameters::ClassMethods
  def parameter_parsers=(parsers); end
end
class ActionDispatch::Http::ParameterFilter
  def compiled_filter; end
  def filter(params); end
  def initialize(filters = nil); end
end
class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def blocks; end
  def call(original_params, parents = nil); end
  def deep_regexps; end
  def initialize(regexps, deep_regexps, blocks); end
  def regexps; end
  def self.compile(filters); end
end
module ActionDispatch::Http::FilterParameters
  def env_filter; end
  def filtered_env; end
  def filtered_parameters; end
  def filtered_path; end
  def filtered_query_string; end
  def initialize; end
  def parameter_filter; end
  def parameter_filter_for(filters); end
end
class ActionDispatch::Http::UploadedFile
  def close(unlink_now = nil); end
  def content_type; end
  def content_type=(arg0); end
  def eof?; end
  def headers; end
  def headers=(arg0); end
  def initialize(hash); end
  def open; end
  def original_filename; end
  def original_filename=(arg0); end
  def path; end
  def read(length = nil, buffer = nil); end
  def rewind; end
  def size; end
  def tempfile; end
  def tempfile=(arg0); end
  def to_io; end
end
module ActionDispatch::Http::URL
  def domain(tld_length = nil); end
  def host; end
  def host_with_port; end
  def initialize; end
  def optional_port; end
  def port; end
  def port_string; end
  def protocol; end
  def raw_host_with_port; end
  def self.add_anchor(path, anchor); end
  def self.add_params(path, params); end
  def self.add_trailing_slash(path); end
  def self.build_host_url(host, port, protocol, options, path); end
  def self.extract_domain(host, tld_length); end
  def self.extract_domain_from(host, tld_length); end
  def self.extract_subdomain(host, tld_length); end
  def self.extract_subdomains(host, tld_length); end
  def self.extract_subdomains_from(host, tld_length); end
  def self.full_url_for(options); end
  def self.named_host?(host); end
  def self.normalize_host(_host, options); end
  def self.normalize_port(port, protocol); end
  def self.normalize_protocol(protocol); end
  def self.path_for(options); end
  def self.tld_length; end
  def self.tld_length=(obj); end
  def self.url_for(options); end
  def server_port; end
  def standard_port; end
  def standard_port?; end
  def subdomain(tld_length = nil); end
  def subdomains(tld_length = nil); end
  def tld_length; end
  def tld_length=(obj); end
  def url; end
end
class ActionDispatch::ContentSecurityPolicy
  def apply_mapping(source); end
  def apply_mappings(sources); end
  def base_uri(*sources); end
  def block_all_mixed_content(enabled = nil); end
  def build(context = nil, nonce = nil); end
  def build_directive(sources, context); end
  def build_directives(context, nonce); end
  def child_src(*sources); end
  def connect_src(*sources); end
  def default_src(*sources); end
  def directives; end
  def font_src(*sources); end
  def form_action(*sources); end
  def frame_ancestors(*sources); end
  def frame_src(*sources); end
  def img_src(*sources); end
  def initialize; end
  def initialize_copy(other); end
  def manifest_src(*sources); end
  def media_src(*sources); end
  def nonce_directive?(directive); end
  def object_src(*sources); end
  def plugin_types(*types); end
  def report_uri(uri); end
  def require_sri_for(*types); end
  def resolve_source(source, context); end
  def sandbox(*values); end
  def script_src(*sources); end
  def style_src(*sources); end
  def upgrade_insecure_requests(enabled = nil); end
  def worker_src(*sources); end
end
class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end
  def header_name(request); end
  def html_response?(headers); end
  def initialize(app); end
  def policy_present?(headers); end
end
module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy; end
  def content_security_policy=(policy); end
  def content_security_policy_nonce; end
  def content_security_policy_nonce_generator; end
  def content_security_policy_nonce_generator=(generator); end
  def content_security_policy_report_only; end
  def content_security_policy_report_only=(value); end
  def generate_content_security_policy_nonce; end
end
class ActionDispatch::Request
  def GET; end
  def POST; end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def authorization; end
  def body; end
  def body_stream; end
  def cache_control; end
  def check_method(name); end
  def client_ip; end
  def commit_cookie_jar!; end
  def commit_flash; end
  def content_length; end
  def controller_class; end
  def controller_class_for(name); end
  def controller_instance; end
  def controller_instance=(controller); end
  def engine_script_name(_routes); end
  def engine_script_name=(name); end
  def form_data?; end
  def from; end
  def fullpath; end
  def gateway_interface; end
  def headers; end
  def http_auth_salt; end
  def ignore_accept_header; end
  def ignore_accept_header=(obj); end
  def initialize(env); end
  def ip; end
  def key?(key); end
  def local?; end
  def logger; end
  def media_type; end
  def method; end
  def method_symbol; end
  def negotiate; end
  def origin; end
  def original_fullpath; end
  def original_script_name; end
  def original_url; end
  def path_translated; end
  def pragma; end
  def query_parameters; end
  def raw_post; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end
  def remote_ip; end
  def remote_ip=(remote_ip); end
  def remote_user; end
  def request_id; end
  def request_id=(id); end
  def request_method; end
  def request_method=(request_method); end
  def request_method_symbol; end
  def request_parameters; end
  def request_parameters=(params); end
  def reset_session; end
  def routes; end
  def routes=(routes); end
  def self.empty; end
  def self.ignore_accept_header; end
  def self.ignore_accept_header=(obj); end
  def self.parameter_parsers; end
  def send_early_hints(links); end
  def server_addr; end
  def server_name; end
  def server_protocol; end
  def server_software; end
  def session=(session); end
  def session_options=(options); end
  def show_exceptions?; end
  def ssl?; end
  def uuid; end
  def version; end
  def x_csrf_token; end
  def x_forwarded_for; end
  def x_forwarded_host; end
  def x_request_id; end
  def xhr?; end
  def xml_http_request?; end
  extend ActionDispatch::Http::Parameters::ClassMethods
  include ActionDispatch::ContentSecurityPolicy::Request
  include ActionDispatch::Http::Cache::Request
  include ActionDispatch::Http::FilterParameters
  include ActionDispatch::Http::MimeNegotiation
  include ActionDispatch::Http::Parameters
  include ActionDispatch::Http::URL
  include Rack::Request::Env
  include Rack::Request::Helpers
end
class ActionDispatch::Request::PASS_NOT_FOUND
  def self.action(_); end
  def self.binary_params_for?(action); end
  def self.call(_); end
end
class ActionDispatch::Routing::Endpoint
  def app; end
  def dispatcher?; end
  def engine?; end
  def matches?(req); end
  def rack_app; end
  def redirect?; end
end
module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options = nil); end
  def edit_polymorphic_url(record_or_hash, options = nil); end
  def new_polymorphic_path(record_or_hash, options = nil); end
  def new_polymorphic_url(record_or_hash, options = nil); end
  def polymorphic_mapping(record); end
  def polymorphic_path(record_or_hash_or_array, options = nil); end
  def polymorphic_path_for_action(action, record_or_hash, options); end
  def polymorphic_url(record_or_hash_or_array, options = nil); end
  def polymorphic_url_for_action(action, record_or_hash, options); end
end
class ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder
  def get_method_for_class(klass); end
  def get_method_for_string(str); end
  def handle_class(klass); end
  def handle_class_call(target, klass); end
  def handle_list(list); end
  def handle_model(record); end
  def handle_model_call(target, record); end
  def handle_string(record); end
  def handle_string_call(target, str); end
  def initialize(key_strategy, prefix, suffix); end
  def polymorphic_mapping(target, record); end
  def prefix; end
  def self.build(action, type); end
  def self.get(action, type); end
  def self.path; end
  def self.plural(prefix, suffix); end
  def self.polymorphic_method(recipient, record_or_hash_or_array, action, type, options); end
  def self.singular(prefix, suffix); end
  def self.url; end
  def suffix; end
end
module ActionDispatch::Routing::UrlFor
  def _routes_context; end
  def _with_routes(routes); end
  def full_url_for(options = nil); end
  def initialize(*arg0); end
  def optimize_routes_generation?; end
  def route_for(name, *args); end
  def url_for(options = nil); end
  def url_options; end
  extend ActiveSupport::Concern
  include ActionDispatch::Routing::PolymorphicRoutes
end
class ActionDispatch::Routing::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end
  def add_route(mapping, name); end
  def add_url_helper(name, options, &block); end
  def api_only?; end
  def append(&block); end
  def call(env); end
  def clear!; end
  def default_scope; end
  def default_scope=(arg0); end
  def default_url_options; end
  def default_url_options=(arg0); end
  def define_mounted_helper(name, script_namer = nil); end
  def disable_clear_and_finalize; end
  def disable_clear_and_finalize=(arg0); end
  def draw(&block); end
  def eager_load!; end
  def empty?; end
  def env_key; end
  def eval_block(block); end
  def extra_keys(options, recall = nil); end
  def finalize!; end
  def find_relative_url_root(options); end
  def find_script_name(options); end
  def formatter; end
  def formatter=(arg0); end
  def generate(route_key, options, recall = nil); end
  def generate_extras(options, recall = nil); end
  def initialize(config = nil); end
  def inspect; end
  def make_request(env); end
  def mounted_helpers; end
  def named_routes; end
  def named_routes=(arg0); end
  def optimize_routes_generation?; end
  def path_for(options, route_name = nil); end
  def polymorphic_mappings; end
  def prepend(&block); end
  def recognize_path(path, environment = nil); end
  def recognize_path_with_request(req, path, extras, raise_on_missing: nil); end
  def relative_url_root; end
  def request_class; end
  def resources_path_names; end
  def resources_path_names=(arg0); end
  def router; end
  def router=(arg0); end
  def routes; end
  def self.default_resources_path_names; end
  def self.new_with_config(config); end
  def set; end
  def set=(arg0); end
  def url_for(options, route_name = nil, url_strategy = nil); end
  def url_helpers(supports_path = nil); end
end
class ActionDispatch::Routing::RouteSet::Dispatcher < ActionDispatch::Routing::Endpoint
  def controller(req); end
  def dispatch(controller, action, req, res); end
  def dispatcher?; end
  def initialize(raise_on_name_error); end
  def serve(req); end
end
class ActionDispatch::Routing::RouteSet::StaticDispatcher < ActionDispatch::Routing::RouteSet::Dispatcher
  def controller(_); end
  def initialize(controller_class); end
end
class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  def [](name); end
  def []=(name, route); end
  def add(name, route); end
  def add_url_helper(name, defaults, &block); end
  def clear!; end
  def clear; end
  def define_url_helper(mod, route, name, opts, route_key, url_strategy); end
  def each; end
  def get(name); end
  def helper_names; end
  def initialize; end
  def key?(name); end
  def length; end
  def names; end
  def path_helpers_module; end
  def route_defined?(name); end
  def routes; end
  def url_helpers_module; end
  include Enumerable
end
class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end
  def handle_positional_args(controller_options, inner_options, args, result, path_params); end
  def initialize(route, options, route_name, url_strategy); end
  def route_name; end
  def self.create(route, options, route_name, url_strategy); end
  def self.optimize_helper?(route); end
  def url_strategy; end
end
class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper < ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def arg_size; end
  def call(t, args, inner_options); end
  def initialize(route, options, route_name, url_strategy); end
  def optimize_routes_generation?(t); end
  def optimized_helper(args); end
  def parameterize_args(args); end
  def raise_generation_error(args); end
end
class ActionDispatch::Routing::RouteSet::Config < Struct
  def api_only; end
  def api_only=(_); end
  def relative_url_root; end
  def relative_url_root=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ActiveSupport::Concern
  include ActionDispatch::Routing::UrlFor
end
class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block; end
  def call(t, args, only_path = nil); end
  def defaults; end
  def eval_block(t, args, options); end
  def initialize(name, defaults, &block); end
  def merge_defaults(options); end
  def name; end
end
class ActionDispatch::Routing::RouteSet::Generator
  def controller; end
  def current_controller; end
  def different_controller?; end
  def generate; end
  def initialize(named_route, options, recall, set); end
  def named_route; end
  def named_route_exists?; end
  def normalize_controller!; end
  def normalize_controller_action_id!; end
  def normalize_options!; end
  def options; end
  def recall; end
  def segment_keys; end
  def set; end
  def use_recall_for(key); end
  def use_relative_controller!; end
end
class ActionDispatch::Routing::Redirect < ActionDispatch::Routing::Endpoint
  def block; end
  def call(env); end
  def escape(params); end
  def escape_fragment(params); end
  def escape_path(params); end
  def initialize(status, block); end
  def inspect; end
  def path(params, request); end
  def redirect?; end
  def relative_path?(path); end
  def serve(req); end
  def status; end
end
class ActionDispatch::Routing::PathRedirect < ActionDispatch::Routing::Redirect
  def inspect; end
  def interpolation_required?(string, params); end
  def path(params, request); end
end
class ActionDispatch::Routing::OptionRedirect < ActionDispatch::Routing::Redirect
  def inspect; end
  def options; end
  def path(params, request); end
end
module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end
class ActionDispatch::Routing::Mapper
  def initialize(set); end
  def self.normalize_name(name); end
  def self.normalize_path(path); end
  include ActionDispatch::Routing::Mapper::Base
  include ActionDispatch::Routing::Mapper::Concerns
  include ActionDispatch::Routing::Mapper::CustomUrls
  include ActionDispatch::Routing::Mapper::HttpHelpers
  include ActionDispatch::Routing::Mapper::Resources
  include ActionDispatch::Routing::Mapper::Scoping
  include ActionDispatch::Routing::Redirection
end
class ActionDispatch::Routing::Mapper::Constraints < ActionDispatch::Routing::Endpoint
  def app; end
  def constraint_args(constraint, request); end
  def constraints; end
  def dispatcher?; end
  def initialize(app, constraints, strategy); end
  def matches?(req); end
  def serve(req); end
end
class ActionDispatch::Routing::Mapper::Mapping
  def add_controller_module(controller, modyoule); end
  def add_wildcard_options(options, formatted, path_ast); end
  def app(blocks); end
  def application; end
  def ast; end
  def blocks(callable_constraint); end
  def build_conditions(current_conditions, request_class); end
  def build_path(ast, requirements, anchor); end
  def check_controller_and_action(path_params, controller, action); end
  def check_part(name, part, path_params, hash); end
  def conditions; end
  def constraints(options, path_params); end
  def default_action; end
  def default_controller; end
  def defaults; end
  def dispatcher(raise_on_name_error); end
  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, blocks, via, options_constraints, anchor, options); end
  def make_route(name, precedence); end
  def normalize_defaults(options); end
  def normalize_format(formatted); end
  def normalize_options!(options, path_params, modyoule); end
  def path; end
  def request_method; end
  def required_defaults; end
  def requirements; end
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end
  def self.check_via(via); end
  def self.normalize_path(path, format); end
  def self.optional_format?(path, format); end
  def split_constraints(path_params, constraints); end
  def split_to(to); end
  def to; end
  def translate_controller(controller); end
  def verify_regexp_requirements(requirements); end
end
module ActionDispatch::Routing::Mapper::Base
  def app_name(app, rails_app); end
  def default_url_options(options); end
  def default_url_options=(options); end
  def define_generate_prefix(app, name); end
  def has_named_route?(name); end
  def match(path, options = nil); end
  def mount(app, options = nil); end
  def rails_app?(app); end
  def with_default_scope(scope, &block); end
end
module ActionDispatch::Routing::Mapper::HttpHelpers
  def delete(*args, &block); end
  def get(*args, &block); end
  def map_method(method, args, &block); end
  def patch(*args, &block); end
  def post(*args, &block); end
  def put(*args, &block); end
end
module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints = nil); end
  def controller(controller); end
  def defaults(defaults = nil); end
  def merge_action_scope(parent, child); end
  def merge_as_scope(parent, child); end
  def merge_blocks_scope(parent, child); end
  def merge_constraints_scope(parent, child); end
  def merge_controller_scope(parent, child); end
  def merge_defaults_scope(parent, child); end
  def merge_format_scope(parent, child); end
  def merge_module_scope(parent, child); end
  def merge_options_scope(parent, child); end
  def merge_path_names_scope(parent, child); end
  def merge_path_scope(parent, child); end
  def merge_shallow_path_scope(parent, child); end
  def merge_shallow_prefix_scope(parent, child); end
  def merge_shallow_scope(parent, child); end
  def merge_to_scope(parent, child); end
  def merge_via_scope(parent, child); end
  def namespace(path, options = nil); end
  def scope(*args); end
end
module ActionDispatch::Routing::Mapper::Resources
  def action_options?(options); end
  def action_path(name); end
  def add_route(action, controller, options, _path, to, via, formatted, anchor, options_constraints); end
  def api_only?; end
  def apply_action_options(options); end
  def apply_common_behavior_for(method, resources, options, &block); end
  def canonical_action?(action); end
  def collection; end
  def decomposed_match(path, controller, options, _path, to, via, formatted, anchor, options_constraints); end
  def get_to_from_path(path, to, action); end
  def map_match(paths, options); end
  def match(path, *rest, &block); end
  def match_root_route(options); end
  def member; end
  def name_for_action(as, action); end
  def namespace(path, options = nil); end
  def nested; end
  def nested_options; end
  def nested_scope?; end
  def new; end
  def param_constraint; end
  def param_constraint?; end
  def parent_resource; end
  def path_for_action(action, path); end
  def path_scope(path); end
  def prefix_name_for_action(as, action); end
  def resource(*resources, &block); end
  def resource_method_scope?; end
  def resource_scope(resource); end
  def resource_scope?; end
  def resources(*resources, &block); end
  def resources_path_names(options); end
  def root(path, options = nil); end
  def scope_action_options; end
  def set_member_mappings_for_resource; end
  def shallow; end
  def shallow?; end
  def shallow_nesting_depth; end
  def shallow_scope; end
  def using_match_shorthand?(path); end
  def with_scope_level(kind); end
end
class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions; end
  def collection_name; end
  def collection_scope; end
  def controller; end
  def default_actions; end
  def initialize(entities, api_only, shallow, options = nil); end
  def member_name; end
  def member_scope; end
  def name; end
  def nested_param; end
  def nested_scope; end
  def new_scope(new_path); end
  def param; end
  def path; end
  def plural; end
  def resource_scope; end
  def shallow?; end
  def shallow_scope; end
  def singleton?; end
  def singular; end
end
class ActionDispatch::Routing::Mapper::Resources::SingletonResource < ActionDispatch::Routing::Mapper::Resources::Resource
  def collection_name; end
  def default_actions; end
  def initialize(entities, api_only, shallow, options); end
  def member_name; end
  def member_scope; end
  def nested_scope; end
  def plural; end
  def singleton?; end
  def singular; end
end
module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable = nil, &block); end
  def concerns(*args); end
end
module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options = nil, &block); end
  def resolve(*args, &block); end
end
class ActionDispatch::Routing::Mapper::Scope
  def [](key); end
  def action_name(name_prefix, prefix, collection_name, member_name); end
  def each; end
  def frame; end
  def initialize(hash, parent = nil, scope_level = nil); end
  def nested?; end
  def new(hash); end
  def new_level(level); end
  def null?; end
  def options; end
  def parent; end
  def resource_method_scope?; end
  def resource_scope?; end
  def resources?; end
  def root?; end
  def scope_level; end
  include Enumerable
end
